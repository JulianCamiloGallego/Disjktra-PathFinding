{"version":3,"sources":["algos/dijkstra.js","components/node/node.js","components/visualizer.js","App.js","index.js"],"names":["dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","col","filter","neighbor","getUnvisitedNeighbors","previousNode","Node","props","state","this","startingNode","endNode","visited","pathNode","onMouseDown","onMouseEnter","onMouseUp","setStartEndNodes","className","Component","Visualizer","mouseIsPressed","choosingStartEndNodes","startingNodeRow","startingNodeCol","endNodeRow","endNodeCol","buildGrid","setState","newNodes","updateWallOnGrid","console","log","visitedNodes","pathNodes","i","setTimeout","animatePath","slice","newNode","nodesInShortestPathOrder","currentNode","unshift","getNodesInShortestPathOrder","animate","Navbar","bg","variant","expand","Brand","href","Toggle","aria-controls","Collapse","id","Nav","Link","NavDropdown","title","Item","onClick","visualize","chooseStartEndNodes","resetNodes","map","rowId","nodeId","handleMouseDown","handleMouseEnter","handleMouseUp","buildingRow","createNode","wallNode","newGrid","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0e08b2de.chunk.js","sourcesContent":["// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n    const visitedNodesInOrder = [];\n    startNode.distance = 0;\n    const unvisitedNodes = getAllNodes(grid);\n    while (!!unvisitedNodes.length) {\n      sortNodesByDistance(unvisitedNodes);\n      const closestNode = unvisitedNodes.shift();\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n}\n  \nfunction sortNodesByDistance(unvisitedNodes) {\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n  \nfunction updateUnvisitedNeighbors(node, grid) {\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const neighbor of unvisitedNeighbors) {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n}\n  \nfunction getUnvisitedNeighbors(node, grid) {\n    const neighbors = [];\n    const {col, row} = node;\n    if (row > 0) neighbors.push(grid[row - 1][col]);\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n    if (col > 0) neighbors.push(grid[row][col - 1]);\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n    return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n  \nfunction getAllNodes(grid) {\n    const nodes = [];\n    for (const row of grid) {\n      for (const node of row) {\n        nodes.push(node);\n      }\n    }\n    return nodes;\n}\n  \n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n    const nodesInShortestPathOrder = [];\n    let currentNode = finishNode;\n    while (currentNode !== null) {\n      nodesInShortestPathOrder.unshift(currentNode);\n      currentNode = currentNode.previousNode;\n    }\n    return nodesInShortestPathOrder;\n}","import React, {Component} from 'react';\n\nimport './node.css';\n\nclass Node extends Component{\n    constructor(props){\n        super(props);\n\n        this.state={\n\n        }\n    }\n\n    render(){\n        const {row, col, startingNode, endNode, visited, pathNode ,isWall, onMouseDown, onMouseEnter, onMouseUp} = this.props;\n\n        const setStartEndNodes = endNode ? 'end-node' : startingNode ? 'starting-node' : visited ? 'visited' : isWall ? 'wall' : pathNode ? 'pathNode' : '';\n\n        return(\n            <div \n            className={`node ${(setStartEndNodes)}`}\n            onMouseDown = {() => onMouseDown(row,col)}    \n            onMouseEnter = {() => onMouseEnter(row,col)}\n            onMouseUp = {() => onMouseUp()}\n            />\n        );\n    }\n}\n\nexport const DEFAULT_NODE = {\n    row: 0,\n    col: 0\n};\n\nexport default Node;","import React, { Component } from 'react';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algos/dijkstra';\n\nimport Node from './node/node';\n\nimport './visualizer.css';\nimport { Navbar, Nav, NavDropdown } from 'react-bootstrap';\n\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst END_NODE_ROW = 15;\nconst END_NODE_COL = 15;\n\nclass Visualizer extends Component{\n    constructor(props){\n        super(props);\n\n        this.state={\n            nodes: [],\n            mouseIsPressed: false,\n            choosingStartEndNodes: false,\n            startingNodeRow: 10,\n            startingNodeCol: 15,\n            endNodeRow: 15,\n            endNodeCol: 15,\n        }\n    }\n\n    \n\n    componentDidMount(){\n        const nodes = buildGrid();\n        this.setState({nodes});\n        \n    }\n\n    handleMouseDown(row, col){\n        if (this.state.choosingStartEndNodes === false){\n            const newNodes = updateWallOnGrid(this.state.nodes, row, col);\n            this.setState({nodes: newNodes, mouseIsPressed: true});\n            \n        }\n        else{\n            this.setState({startingNodeRow: row, startingNodeCol: col})\n            console.log(this.state.startingNodeRow, this.state.startingNodeCol);\n        }\n    }\n\n    handleMouseEnter(row, col){\n        //if (this.state.choosingStartEndNodes === false){\n        //    if (!this.state.mouseIsPressed) return;\n\n        //    const newNodes = updateWallOnGrid(this.state.nodes, row, col);\n        //    this.setState({nodes: newNodes});\n        //}\n    }\n\n    handleMouseUp(){\n        if (this.state.choosingStartEndNodes === false){\n            this.setState({mouseIsPressed: false});\n        }\n    }\n\n    animate(visitedNodes, pathNodes){\n        for (let i = 0; i <= visitedNodes.length; i++){\n            if (i === visitedNodes.length){\n                setTimeout(() => {\n                    this.animatePath(pathNodes);\n                }, 25 * i)\n            return;\n            }\n\n            setTimeout(() => {\n                const newNodes = this.state.nodes.slice();\n\n                const node = visitedNodes[i];\n                const newNode = {\n                    ...node,\n                    visited: true,\n                }\n                newNodes[node.row][node.col] = newNode;\n                this.setState({nodes: newNodes});\n            }, 25 * i);\n        }\n    }\n\n    animatePath(pathNodes){\n        for (let i = 0; i < pathNodes.length; i++){\n\n            setTimeout(() => {\n                const newNodes = this.state.nodes.slice();\n\n                const node = pathNodes[i];\n                const newNode = {\n                    ...node,\n                    pathNode: true,\n                }\n            \n                newNodes[node.row][node.col] = newNode;\n                this.setState({nodes: newNodes});\n            }, 25 * i);\n        }\n    }\n\n    visualize(){\n        const {nodes} = this.state;\n\n        const startingNode = nodes[this.state.startingNodeRow][this.state.startingNodeCol];\n        const endNode = nodes[this.state.endNodeRow][this.state.endNodeCol];\n\n        const visitedNodes = dijkstra(nodes, startingNode, endNode);\n        const pathNodes = getNodesInShortestPathOrder(endNode);\n        \n        this.animate(visitedNodes, pathNodes);\n\n    }\n\n    resetNodes(){\n        const nodes = buildGrid();\n        this.setState({nodes});\n    }\n\n    chooseStartEndNodes(){\n        this.setState({choosingStartEndNodes: true});\n    }\n\n    render(){\n        const {nodes} = this.state;\n\n        return(\n            <>\n            <Navbar bg=\"dark\" variant=\"dark\" expand=\"lg\">\n                <Navbar.Brand href=\"#home\"> PathFinder </Navbar.Brand>\n                <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\n                <Navbar.Collapse id=\"basic-navbar-nav\">\n                    <Nav className=\"mr-auto\">\n                    <Nav.Link href=\"#home\"> About </Nav.Link>\n                    <Nav.Link href=\"#link\"> Help  </Nav.Link>\n                    <NavDropdown title=\"Actions\" id=\"basic-nav-dropdown\">\n                        <NavDropdown.Item onClick={() => this.visualize()}> Find Path </NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => this.chooseStartEndNodes()}> Choose Start/End Node </NavDropdown.Item>\n                        <NavDropdown.Item onClick={() => this.resetNodes()}> Reset </NavDropdown.Item>\n                    </NavDropdown>\n                    </Nav>\n                </Navbar.Collapse>\n            </Navbar>\n\n            <div className=\"grid\">\n                {nodes.map((row, rowId) => {\n                    return(\n                        <div key={rowId}>\n                            {row.map((node, nodeId) => {\n                                const {row, col, startingNode, endNode, visited, pathNode, isWall, mouseIsPressed} = node;\n                                return(\n                                    <Node\n                                        row={row}\n                                        col={col}\n                                        key={nodeId}\n                                        startingNode={startingNode}\n                                        endNode={endNode}\n                                        visited={visited}\n                                        pathNode={pathNode}\n                                        isWall={isWall}\n                                        mouseIsPressed={mouseIsPressed}\n                                        onMouseDown = {(row, col) => this.handleMouseDown(row,col)}\n                                        onMouseEnter = {(row, col) => this.handleMouseEnter(row, col)}\n                                        onMouseUp = {() => this.handleMouseUp()}\n                                    />\n                                );\n                            })}\n                        </div>\n                    ); \n                })}\n            </div>\n            </>\n        );\n    }\n}\n\nconst buildGrid = () =>{\n    const nodes = [];\n        \n    for (let row = 0; row < 25; row++){\n        const buildingRow = [];\n        for (let col = 0; col < 50; col++){\n            buildingRow.push(createNode(row,col));\n        }\n        nodes.push(buildingRow);\n    }\n    return nodes\n};\n\nconst createNode = (row,col) => {\n    //Creates a new node\n\n    return{\n        col,\n        row,\n        startingNode: row === START_NODE_ROW && col === START_NODE_COL,\n        endNode: row === END_NODE_ROW && col === END_NODE_COL,\n        distance: Infinity,\n        visited: false,\n        wallNode: false,\n        previousNode: null\n    }\n};\n\nconst updateWallOnGrid = (grid, row, col) => {\n    //!Make so this works for updating both wall and start/end nodes\n    //Updates the grid with a newly added wallNode\n\n    const newGrid = grid.slice(); //Returns copy of the grid array\n    \n    const wallNode = newGrid[row][col];\n\n    const newNode = {\n        ...wallNode,\n        isWall: !wallNode.isWall\n    };\n    newGrid[row][col] = newNode;\n\n    return newGrid;\n};\n\nexport default Visualizer;","import Visualizer from './components/visualizer';\n\nfunction App() {\n\n  return (\n    <div>\n     <Visualizer/>\n    </div>\n  );\n}\n\nexport default App;\n","import 'bootstrap/dist/css/bootstrap.min.css';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nimport './index.css';\n\nReactDOM.render(\n    <App />\n    \n    ,document.getElementById('root')\n);\n\n"],"sourceRoot":""}